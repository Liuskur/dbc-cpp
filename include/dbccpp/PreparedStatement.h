#ifndef DBCCPP_PREPAREDSTATEMENT_H__
#define DBCCPP_PREPAREDSTATEMENT_H__

#include <dbccpp/ResultSet.h>
#include <dbccpp/CountProxy.h>
#include <utilcpp/declarations.h>

#include <string>

#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
  #include <memory>
  #include <type_traits>
  namespace stdutil = std;
#else
  #include <boost/smart_ptr/shared_ptr.hpp>
  #include <boost/type_traits.hpp>
  namespace stdutil = boost;
#endif

namespace dbc
{

class CountProxy;

/** Interface for representing precompiled SQL statements.
 *
 * A SQL statement is precompiled and stored in a PreparedStatement object.
 * This object can then be used to efficiently execute this statement multiple
 * times.
 *
 * The SQL statement must be a UTF-8 string.
 *
 * @throw DbException
 */
class PreparedStatement
{
    UTILCPP_DECLARE_INTERFACE(PreparedStatement)

public:

    typedef stdutil::shared_ptr<PreparedStatement> ptr;

    /** Bind value to the prepared statement at the given index.
     *
     * Uses std::enable_if<> and std::is_pod<> to pass POD types
     * by value and non-POD types by const reference.
     *
     * @throw DbException
     */
    template <typename T>
    typename stdutil::enable_if<stdutil::is_pod<T>, void>::type
    set(int parameterIndex, T val);

    template <typename T>
    typename stdutil::disable_if<stdutil::is_pod<T>, void>::type
    set(int parameterIndex, const T& val);

    /** Bind null to the prepared statement.
     *
     * @throw DbException
     */
    virtual void setNull(int parameterIndex) = 0;

    /** Reset the prepared statement object back to its initial state, ready
     * to be re-executed.
     *
     * Contrary to the intuition of many, any bound variables retain their
     * values.
     *
     * @throw DbException
     */
    virtual void reset() = 0;

    /** Clear all bound parameters.
     *
     * @throw DbException
     */
    virtual void clear() = 0;

    /** Execute the SQL query in this PreparedStatement object and return the
     * RecordSet object generated by the query.
     *
     * @return RecordSet object that contains the data produced
     * by the query; never null
     *
     * @throw DbException
     */
    virtual ResultSet::ptr executeQuery() = 0;

    /** Execute a SQL Data Manipulation or Definition Language statement.
     *
     * Returns instance of a CountProxy that will not evaluate the expensive
     * row count calculation unless it is captured in an int variable.
     *
     * If you need the to evaluate the count, use it as follows:
     *
     *   int count = statement.executeUpdate();
     *
     * otherwise just
     *
     *   statement.executeUpdate();
     *
     * (which will not evaluate the count).
     *
     * @return either (1) the row count for DML statements or (2) 0 for
     * statements that return nothing
     *
     * @throw DbException
     */
    virtual const CountProxy& executeUpdate() = 0;

    /** Return the row id of the most recent successful INSERT into the
     * active database. If the insert was made to a table that has a column
     * of type INTEGER PRIMARY KEY then the last value from that column is
     * used, otherwise the internal rowid value .
     *
     * @return last insert row id
     *
     * @throw DbException
     */
    // FIXME: this should be a 64-bit type really
    // FIXME: information is SQLite-specific
    virtual int getLastInsertId() = 0;

    /** Get the underlying SQL statement. */
    virtual const char* getSQL() const = 0;

protected:
    // NVI for set()
    virtual void setString(int parameterIndex, const std::string& val) = 0;
    virtual void setInt(int parameterIndex, const int& val) = 0;
    virtual void setDouble(int parameterIndex, const double& val) = 0;
    virtual void setBool(int parameterIndex, const bool& value) = 0;
};

class ParameterTrackerMixin
{
public:
    ParameterTrackerMixin(unsigned int num_params) :
        _num_params(num_params),
        _set_params_tracker(0)
    {}

    void setParameter(unsigned int index)
    {
        if (index < 1 || index > 63 || index > _num_params)
            throw std::runtime_error("out of range");

        // index is 1-based, tracker 0-based
        _set_params_tracker |= (1U << (index - 1));
    }

    bool areAllParamsSet()
    {
        unsigned int num_params_mask = ~(~0U << _num_params);
        return ((_set_params_tracker & num_params_mask) == num_params_mask);
    }

private:
    unsigned int _num_params;
    unsigned int _set_params_tracker;
};

}

#endif /* DBCCPP_PREPAREDSTATEMENT_H__ */
