#ifndef DBCCPP_PREPAREDSTATEMENT_H__
#define DBCCPP_PREPAREDSTATEMENT_H__

#include <dbccpp/ResultSet.h>
#include <dbccpp/CountProxy.h>
#include <dbccpp/PreparedStatementBinder.h>
#include <utilcpp/declarations.h>

#include <string>

#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
  #include <memory>
  #include <type_traits>
  namespace dbc
  {
      namespace stdutil = std;
  }
#else
  #include <boost/smart_ptr/shared_ptr.hpp>
  #include <boost/type_traits.hpp>
  namespace dbc
  {
      namespace stdutil = boost;
  }
#endif

namespace dbc
{

class CountProxy;

/** Interface for representing precompiled SQL statements.
 *
 * A SQL statement is precompiled and stored in a PreparedStatement object.
 * This object can then be used to efficiently execute this statement multiple
 * times.
 *
 * The SQL statement must be a UTF-8 string.
 *
 * @throw DbException
 */
class PreparedStatement
{
    UTILCPP_DECLARE_INTERFACE(PreparedStatement)

public:

    typedef stdutil::shared_ptr<PreparedStatement> ptr;

    /** Bind value to the prepared statement at the given index.
     *
     * This interface is low-level, it is adviseable to use the
     * operator<<()-based binding instead where possible.
     *
     * Indexing is 1-based as per SQLite binding API.
     *
     * Uses std::enable_if<> and std::is_pod<> to pass POD types
     * by value and non-POD types by const reference.
     *
     * @throw DbException
     */
    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<std::is_pod<T>::value, void>::type
#else
    typename boost::enable_if<boost::is_pod<T>, void>::type
#endif
    set(int parameterIndex, T val);

    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<!std::is_pod<T>::value, void>::type
#else
    typename boost::disable_if<boost::is_pod<T>, void>::type
#endif
    set(int parameterIndex, const T& val);

    /** Bind null to the prepared statement.
     *
     * @throw DbException
     */
    virtual void setNull(int parameterIndex) = 0;

    /** A convenient ostream-like wrapper around set() for binding values
     * to the prepared statement in one go. E.g. binding values to statement
     *
     *   "SELECT * FROM PERSON WHERE name = ? AND age = ?"
     *
     * would work as follows:
     *
     *   *statement << "Ervin" << 38;
     *
     * Uses std::enable_if<> and std::is_pod<> to pass POD types
     * by value and non-POD types by const reference.
     *
     * Returns the PreparedStatementBinder proxy object, a lightweight
     * temporary binder that should not be used directly.
     *
     * @throw DbException
     */
    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<std::is_pod<T>::value, PreparedStatementBinder>::type
#else
    typename boost::enable_if<boost::is_pod<T>, PreparedStatementBinder>::type
#endif
    operator<<(T val)
    { PreparedStatementBinder ret(*this, 1); ret.bind(val); return ret; }

    template <typename T>
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus > 199711L)
    typename std::enable_if<!std::is_pod<T>::value, PreparedStatementBinder>::type
#else
    typename boost::disable_if<boost::is_pod<T>, PreparedStatementBinder>::type
#endif
    operator<<(const T& val)
    { PreparedStatementBinder ret(*this, 1); ret.bind(val); return ret; }

    /** Reset the prepared statement object back to its initial state, ready
     * to be re-executed.
     *
     * Contrary to the intuition of many, any bound variables retain their
     * values.
     *
     * @throw DbException
     */
    virtual void reset() = 0;

    /** Clear all bound parameters.
     *
     * @throw DbException
     */
    virtual void clear() = 0;

    /** Execute the SQL query in this PreparedStatement object and return the
     * RecordSet object generated by the query.
     *
     * @return RecordSet object that contains the data produced
     * by the query; never null
     *
     * @throw DbException
     */
    virtual ResultSet::ptr executeQuery() = 0;

    /** Execute a SQL Data Manipulation or Definition Language statement.
     *
     * Returns instance of a CountProxy that will not evaluate the expensive
     * row count calculation unless it is captured in an int variable.
     *
     * If you need the to evaluate the count, use it as follows:
     *
     *   int count = statement.executeUpdate();
     *
     * otherwise just
     *
     *   statement.executeUpdate();
     *
     * (which will not evaluate the count).
     *
     * @return either (1) the row count for DML statements or (2) 0 for
     * statements that return nothing
     *
     * @throw DbException
     */
    virtual const CountProxy& executeUpdate() = 0;

    /** Return the row id of the most recent successful INSERT into the
     * active database. If the insert was made to a table that has a column
     * of type INTEGER PRIMARY KEY then the last value from that column is
     * used, otherwise the internal rowid value .
     *
     * @return last insert row id
     *
     * @throw DbException
     */
    // FIXME: this should be a 64-bit type really
    // FIXME: information is SQLite-specific
    virtual int getLastInsertId() = 0;

    /** Get the underlying SQL statement. */
    virtual const char* getSQL() const = 0;

protected:
    // NVI for set()
    virtual void setString(int parameterIndex, const std::string& val) = 0;
    virtual void setInt(int parameterIndex, const int& val) = 0;
    virtual void setDouble(int parameterIndex, const double& val) = 0;
    virtual void setBool(int parameterIndex, const bool& value) = 0;
};

}

#endif /* DBCCPP_PREPAREDSTATEMENT_H__ */
